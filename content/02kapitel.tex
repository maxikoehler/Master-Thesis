%!TEX root = ../main.tex

% \begingroup
% \newgeometry{left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm}
% \part{Methodical}

% \endgroup
% A room without books is like a body without a soul.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Transformer Equipment Modeling}

\begin{textblock*}{.7\textwidth}(70mm,25mm)
        \begin{fquote}[Mae West]
                You only live once, but if you do it right, once is enough.
        \end{fquote}
\end{textblock*}

Some literature and fundamentals about transformers, control, stability assessment, fast-switching modules, and analysis in Python. \todo{Hier steht ein Beispielkommentar.}

% \begin{figure}[H]
%         \centering
%         \vspace{1cm}
%         \begin{circuitikz}[european, scale=.9, smallR/.style={resistor,resistors/scale=.7}]
%                 \draw (0,0) node[oscillator, anchor=east, name=gen]{} --(.5,0)
%                 to[L, name=X_g] ++(2,0) coordinate(f1)
%                 % \bushere{1}{$\underline{E}_\mathrm{T}'$}{}
%                 % to[oosourcetrans,prim=delta,sec=wye] ++(2,0)
%                 \bushere{2}{$\underline{V}_\mathrm{bb}$}{\acs{SG} bus bar} coordinate(b1) ++(0,-1) -- ++(.25,0) -- coordinate(f2) ++(1.75,0)
%                 to[L, name=X_l3] ++(1,0) -- ++(1.5,0) ++(0,1)
%                 \bushere{2}{$E_\mathrm{ibb}~\angle~0^{\circ}$}{\acs{IBB}} ++(0,1) coordinate(b2) ++(0,-1) coordinate(b3) -- ++(.75,0) coordinate(f3) -- ++(.75,0) to[L, name=X_ibb] ++(1,0) -- ++(1,0)
%                 node[gridnode, anchor=left, name=ib]{};

%                 % draw other resistances
%                 \draw (b1) ++(0,1) -- ++(.5,0) to[L, name=X_l1] (b2);
%                 \draw (b1) -- ++(.5,0) to[L, name=X_l2] (b3);
%                 % \draw[line width=2pt] (2.25,1) -- (2.25,-1);
%                 % \draw[line width=2pt] (4.75,1) -- (4.75,-1);
%                 % \draw[line width=2pt] (8.25,1) -- (8.25,-1);

%                 % labels for the resistors
%                 \node[above=6pt] at (X_g) {$X_\mathrm{g}'$};
%                 \node[above=6pt] at (X_ibb) {$X_\mathrm{ibb}$};
%                 \node[above=6pt] at (X_l1) {$3~X_\mathrm{l}$};
%                 % \node[below=6pt] at (X_l2) {$X_\mathrm{l}$};
%                 % \node[below=6pt] at (X_l3) {$X_\mathrm{l}$};

%                 % pole voltages and angles
%                 \path[->] (-1.2,.5) edge [bend right] node[left=6pt]{$E_\mathrm{p}~\angle~\delta$} (-1.2,-.5);
%                 % \path[->] (ib) ++(.8,.5) edge [bend left] node[right=6pt]{$E_\mathrm{ibb}~\angle~0^{\circ}$} ++(0,-1);

%                 % faults
%                 % \draw[-Stealth, very thick, red] (f1) ++(0,-.5) -- ++(-.15,-.45) -- ++(.3,.2) -- ++(-.2,-.6) coordinate(f1_text);
%                 % \node[below, red] at (f1_text) {\scriptsize fault 1};
%                 \draw[-Stealth, very thick, red] (f2) ++(0,.3) -- ++(-.15,-.45) -- ++(.3,.2) -- ++(-.2,-.6) coordinate(f2_text);
%                 \node[below, red, align=center] at (f2_text) {\scriptsize fault 2/3};
%                 \draw[-Stealth, very thick, red] (f3) ++(0,.3) -- ++(-.15,-.45) -- ++(.3,.2) -- ++(-.2,-.6) coordinate(f3_text);
%                 \node[below, red] at (f3_text) {\scriptsize fault 1};
%         \end{circuitikz}
%         \vspace{.5cm}
%         \caption[Representative circuit of a \acf{SMIB} model]{Representative circuit of a \acf{SMIB} model with pole wheel voltage $E_\mathrm{p}~\angle~\delta$ and \acf{IBB} voltage $E_\mathrm{ibb}~\angle~0^{\circ}$; positions of considered faults 1 to 3 are marked with red lightning arrows}
%         \label{fig:smib-model}
% \end{figure}

\begin{figure}[h]
        \centering
        \begin{tikzpicture}[node distance = 1.5cm, auto]
                % Place nodes
                \node [papStart] (start) {start};
                \node [papProcess, below of = start, yshift= -2mm] (pro1){initialize start and simulation parameters};
                \node [papPredProc, below of = pro1, yshift= -5mm] (pro2){\nodepart{two} \shortstack{do \acs{TDS} with\\constant fault}};
                \node [papProcess, below of = pro2, yshift= -5mm] (pro3){determine \acs{CCT} and critical angle};
                \node [papPredProc, below of = pro3, yshift= -7mm](pro4){\nodepart{two}\shortstack{solving \acs{TDS}\\stable and unstable}};
                \node [papProcess, below of = pro4, yshift= -5mm](pro5){plot results};
                \node [papEnd, below of = pro5, yshift= -2mm] (end) {end};

                \node [right of = pro4, xshift=25mm] (iter) {\footnotesize\itshape{iterate 1x}};
                \node [right of = pro1, xshift=25mm] () {\footnotesize\itshape{init()}};
                \node [right of = pro2, xshift=25mm] () {\footnotesize\itshape{odeint()}};
                \node [right of = pro3, xshift=25mm] () {\footnotesize\itshape{determine\_cct()}};

                % Place joins
                \coordinate [above = of pro4, yshift= -9mm] (join1);
                \coordinate [below of = pro4, yshift= 5mm] (join2);

                % Draw edges
                \path [papLine] (start) -- (pro1);
                \path [papLine] (pro1) -- (pro2);
                \path [papLine] (pro2) -- (pro3);
                \path [papLine] (pro3) -- (pro4);
                \path [papLine] (pro4) -- (pro5);
                \path [papLine] (pro5) -- (end);
                \path [papLine] (join2) -| (iter);
                \path [papLine] (iter) |- (join1);
                % \path [papLine] (dec1) -- node [above] {\papNo} (predproc1);
                % \path [papLine] (predproc1) -- (pro3);
                % \path [papLine] (pro3) |- (join1);
        \end{tikzpicture}
        \caption[Program plan proposal for determining the \acf{CCT}]{Program plan proposal for determining the \acf{CCT} $t_\mathrm{cc}$, critical power angle $\delta_\mathrm{cc}$ and the \acf{TDS} of the \acf{SMIB}-model; including the associated main function name}
        \label{fig:program-plan}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Current implementation of transformers}

\commenting{Describe the current implementation of transformers in the Python framework.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Dynamic behavior of transformers}

\commenting{This is the description of the \glqq new\grqq implementation.}

\subsection{Model Demands and Changes in the Framework}

\subsection{Additional Modifications through a Fast Switching module}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tap Changer Control Modeling}

\commenting{This is the description of the ideas, development, and implementation of a OLTC control scheme.}

\subsection{Discrete Control Loop}
This control method represents the currently most used and thus representative control scheme for \acsp{OLTC}. With the mechanic nature of the switching mechanism, the control look can only access discrete ratios within time frames of around a few seconds. Such a discrete control loop is described by \textcite{milanoHybridControlModel2011,milanoPowerSystemModelling2010}. A scheme of this control loop is shown in \autoref{fig:discrete-control-loop}.

\begin{figure}[htb!]
        \centering
        \missingfigure{Discrete control loop}
        \caption{Discrete control loop of an \acs{OLTC}; scheme based on \textcite{milanoHybridControlModel2011}}
        \label{fig:discrete-control-loop}
\end{figure}

This control loop type is beneficial due to its accurate representability of current \acs{OLTC} abilities. It gains access to assess stability within simulation environments, as analytical methods are not suited.

A negative aspect of a discrete control loop is the missing opportunity of generating a transfer function. This blocks the stability assessment with standard control engineering methods. Further, popular analysis methods like eigenvalue analysis is not possible, due to the lack of possibility to form derivatives.

\commenting{
        \begin{itemize}
                \item Describe implementation
                \item Describe benefits / drawbacks
                \item Control scheme
                \item Switching logic and behavior (voltage tracking)
        \end{itemize}
}

\subsection{Continous Control Loop}

\begin{figure}[htb!]
        \centering
        \includegraphics[width=.7\linewidth]{development_files/data/oltc_control_characterization.pdf}
        \caption[short]{Characterization of the OLTC control loop; the input function simulates the to be regulated voltage, the output functions are characterized by $o(t)=i(t) \cdot \underline{\vartheta}_\mathrm{trafo}$}
        \label{fig:oltc-control-characterization}
\end{figure}

\subsection{Control Schemes for the Fast Switching module}

\subsubsection{Discrete Control Loop as most Representative}
A continous control loop for a \acs{FSM} is presented within \textcite{burlakinEnhancedVoltageControl2024,burlakinEnhancingVariableShunt2024}. Similar to the solely \acs{OLTC} loop, it represents the real behavior best, but is obstructive for stability assessments. The scheme of the logic is shown in \autoref{fig:fsm-continuous-control-loop}.

\begin{figure}[htb!]
        \centering
        \missingfigure{Continuous control loop of a FSM}
        \caption{Continuous control loop of a \acs{FSM}; scheme based on \textcite{burlakinEnhancedVoltageControl2024}}
        \label{fig:fsm-continuous-control-loop}
\end{figure}

\subsubsection{Continuous Control Loop for best Stability Assessment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Supplementary Modeling of Additional Components}

As the python framework is currently missing some representations of components, this chapter aims to describe the implementation of those. Mainly focussing on source and load models, as the later considered test, benchmark, and use case networks require alternative behaviors. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Load Models}

\subsection{ZIP Load Models}

\commenting{Why important?}

Mostly, a polynomial load model is used. It is called ZIP-model, as there are individual contributions to constant impedance $\underline{Z}$, constant current $\underline{I}$, and constant power $P$, or respectively $Q$, are considered. The model is described by \textcite{IEEEGuideLoad2022}. Either two ways of mathematical description are considered valid, dependent on the allowed influence of the frequency deviation. The use of periodized phasor representation, typical for a \acs{RMS} simulation, is missing or often neglecting this frequency information. Therefore the set of \autoref{eq:zip-1} and \autoref{eq:zip-2} is considered sufficient and implemented in the Python framework.
\begin{align}
        P&=P_n \cdot \Bigg[ p_1 \Bigg(\frac{U}{U_n}\Bigg)^2 + p_2 \Bigg(\frac{U}{U_n}\Bigg) + p_3 \Bigg] \label{eq:zip-1} \\[12pt]
        Q&=Q_n \cdot \Bigg[ q_1 \Bigg(\frac{U}{U_n}\Bigg)^2 + q_2 \Bigg(\frac{U}{U_n}\Bigg) + q_3 \Bigg] \label{eq:zip-2} \\[12pt]
        \text{with} \quad &p_i \in [0,1] \quad \text{and} \quad p_i \in [0,1] \notag
\end{align}

\commenting{Characteristics?}

\begin{figure}[htb!]
        \centering
        % \begin{subfigure}[b]{.45\linewidth}
        %         \centering
        %         \includegraphics[width=\linewidth]{development_files/data/zip-load_characterization_impedance.pdf}
        %         \vspace*{4pt}
        %         \caption{}
        %         \label{fig:zip-charac-y}
        % \end{subfigure}
        % \begin{subfigure}[b]{.45\linewidth}
        %         \centering
        %         \includegraphics[width=\linewidth]{development_files/data/zip-load_characterization_power.pdf}
        %         \vspace*{4pt}
        %         \caption{}
        %         \label{fig:zip-charac-p}
        % \end{subfigure}
        \includegraphics[width=\linewidth]{development_files/data/zip-load_characterization_full.pdf}
        \caption[Characterization of the ZIP load model]{Characterization of the ZIP load model; with (upper) the result of the impedances dependent on the voltage at the connected bus, and (lower) the resulting power consumption of the different models, representative only the real power $P$}
        \label{fig:zip-charac}
\end{figure}

\commenting{How does it look like in the simulation environment?}

% \begin{align}
%         P&=P_n \cdot \Bigg[ p_1 \Bigg(\frac{U}{U_n}\Bigg)^2 + p_2 \Bigg(\frac{U}{U_n}\Bigg) + p_3 \Bigg] \cdot (1+k_{pf} \Delta f) \label{eq:zip-with-f-1} \\[12pt]
%         Q&=Q_n \cdot \Bigg[ q_1 \Bigg(\frac{U}{U_n}\Bigg)^2 + q_2 \Bigg(\frac{U}{U_n}\Bigg) + q_3 \Bigg] \cdot (1+k_{qf} \Delta f) \label{eq:zip-with-f-2} \\[12pt]
%         \text{with} \quad &\sum_{i=1}^{3} p_i =1 \quad \text{and} \quad \sum_{i=1}^{3} q_i =1 \notag
% \end{align}

% Although the subset of \autoref{eq:zip-with-f-1} and \autoref{eq:zip-with-f-2} would consider a relation to the frequency at the given time, it is not used. The use of periodized phasor representation, typical for a \acs{RMS} simulation, is missing this information. Therefore the set of \autoref{eq:zip-1} and \autoref{eq:zip-2} is implemented in the Python framework.

\subsection{Induction Machine Models}

As one of the most important loads to consider, especially for many load driven instability mechanisms, the \ac{IM} is a crucial component, \quelle

\commenting{
        Just briefly:
        \begin{itemize}
                \item Why is it crucial?
                \item How do the instability mechanisms work and look like?
                \item What are the different types of \acsp{IM} modeling (complete and dynamic, static, \dots)
        \end{itemize}
}

Three main ways of \acs{IM} modeling are relevant to mention in this section:
\begin{enumerate}
        \item Static model as introduced in \textcite{IEEEGuideLoad2022},
        \item a dynamic 'fixed-speed' \acs{IM} model, and
        \item a doubly fed \acs{IM} model.
\end{enumerate} 
The last ones are mentioned and further described in \textcite{machowskiPowerSystemDynamics2020}. Least model requires very detailed information, and shall be suitable for \acs{SMIB} models for machine behavior studies or similar. The second model is suitable for network analysis and machine behaviors. The first model applies for high perception of \acsp{IM} in total loading of the network. As referencing to \textcite{IEEEGuideLoad2022}, is is similar implemented as the before mentioned ZIP load model, considering characteristic equations for its real power $P$ and reactive power $Q$. Both models shall be described in the following section.

\subsubsection{Static Model of Induction Machines}

For this operational unit type is a detailed dynamic modeling possible. With some considerations, it can be sufficient, modeling this equipment just with the  The model is described by \textcite{IEEEGuideLoad2022} as formulated in following set of equations. %\autoref{eq:im-model}.

\begin{align}
        P&=\Bigg( R_\mathrm{s} + \frac{R_\mathrm{r}}{s} \Bigg) \cdot \frac{U^2}{\Big( R_\mathrm{s} + \frac{R_\mathrm{r}}{S} \Big)^2 + (X_\mathrm{\gamma s} + X_\mathrm{\gamma r})^2} \\[12pt]
        Q&=(X_\mathrm{\gamma s} + X_\mathrm{\gamma r}) \cdot \frac{U^2}{\Big( R_\mathrm{s} + \frac{R_\mathrm{r}}{S} \Big)^2 + (X_\mathrm{\gamma s} + X_\mathrm{\gamma r})^2} + \frac{U^2}{X_\mathrm{s}}
\end{align}
\mycomment[MK]{Is here really a difference between the two s in the equations?}

\commenting{Briefly describe the implementation.}


\subsubsection{Dynamic 'fixed-speed' Induction Machine model'}

\ai{\textbf{From ChatGPT:}

The dynamic model of \acsp{IM} is essential for accurately representing their behavior under various operating conditions. This model includes the differential equations that describe the machine's electrical and mechanical dynamics. The equations are typically derived from the machine's equivalent circuit and can be expressed in the d-q reference frame.

The dynamic model can be represented by the following set of equations:

\begin{align}
        \frac{\dd\psi_\mathrm{d}}{dt} &= v_\mathrm{d} - R_\mathrm{s} i_\mathrm{d} + \omega \psi_\mathrm{q} \\[12pt]
        \frac{\dd\psi_\mathrm{q}}{dt} &= v_\mathrm{q} - R_\mathrm{s} i_\mathrm{q} - \omega \psi_\mathrm{d} \\[12pt]
        \frac{\dd\omega}{dt} &= \frac{1}{J} (T_m - T_e - B \omega)
\end{align}

where:
\begin{itemize}
        \item $\psi_\mathrm{d}, \psi_\mathrm{q}$ are the d-q axis flux linkages
        \item $v_\mathrm{d}, v_\mathrm{q}$ are the d-q axis voltages
        \item $i_\mathrm{d}, i_\mathrm{q}$ are the d-q axis currents
        \item $R_\mathrm{s}$ is the stator resistance
        \item $\omega$ is the rotor angular velocity
        \item $T_\mathrm{m}$ is the mechanical torque
        \item $T_\mathrm{e}$ is the electromagnetic torque
        \item $J$ is the moment of inertia
        \item $B$ is the damping coefficient
\end{itemize}

The electromagnetic torque $T_e$ can be calculated as:

\begin{align}
        T_e = \frac{3}{2} p (\psi_d i_q - \psi_q i_d)
\end{align}

where $p$ is the number of pole pairs.

This dynamic model allows for the simulation of the \acsp{IM} transient response to changes in voltage, frequency, and load conditions. It is particularly useful for studying stability and control strategies in power systems.

}

\commenting{Briefly describe the implementation.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Source Models}

\subsection{PQ Source without Machine Dynamics}

\commenting{Isn't that quite the same as the ZIP load model, but with inversed Power characteristics? Or is there more, for example when looking at a short circuit event\dots}

\commenting{
        These sections (per module / model) should contain roughly follwing information and / or structure:
        \begin{enumerate}
                \item Why is this model important?
                \item How is it implemented?
                \item What are the characteristics (show in plots, description, etc.)?
                \item How does it look like in the simulation environment? -> Smaller example networks, like the \acs{SMIB} model; most likely combined with verification data of PowerFactory.
        \end{enumerate}
}